Searching and Sorting codes:

1. Binary Search:

// You are using GCC
#include <stdio.h>
int binary_search(int arr[],int l, int h, int t){
    if(l>h) return -1;
    else if(l<=h){
        int mid=(l+h)/2;
        if(arr[mid]==t) return mid;
        else if(arr[mid]<t) return binary_search(arr,mid+1,h,t); //l=mid+1;
        else if(arr[mid]>t) return binary_search(arr,l,mid-1,t); //h=mid-1;
    }
}
int main(){
    int n;
    scanf("%d",&n);
    int arr[n];
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    int t;
    scanf("%d",&t);
    int z=binary_search(arr,0,n-1,t);
    printf("%d",z);
}

2. Bubble sort:
3. Insertion sort:
4. Selection Sort:

// You are using GCC
#include <stdio.h>

void insertionSort(int arr[], int n){
    for(int i=0;i<n;i++){
        int temp=arr[i];
        int j=i-1;
        while(j>=0 && arr[j]>temp){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=temp;
    }
}

void selectionSort(int arr[], int n){
    for(int i=0;i<n-1;i++){
        int min=i;
        for(int j=i+1;j<n;j++){
            if(arr[j]<arr[min]){
                min=j;
            }
        }
        if(min!=i){
            int temp=arr[i];
            arr[i]=arr[min];
            arr[min]=temp;
        }
    }
}

void bubbleSort(int arr[], int n){
    for(int i=0;i<n-1;i++){
        for(int j=i+1;j<n;j++){
            if(arr[i]>arr[j]){
                int temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
        }
    }
}

int main(){
    int n;
    scanf("%d",&n);
    int arr[n];
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    insertionSort(arr,n);
    selectionSort(arr,n);
    bubbleSort(arr,n);
    for(int i=0;i<n;i++){
        printf("%d ",arr[i]);
    }
}


5. Counting Sort:

//Counting sort
#include <stdio.h>
int main(){
    int n;
    scanf("%d",&n);
    int arr[n];
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    int count[100]={0};
    int b[n];
    for(int i=0;i<n;i++){
        count[arr[i]]++;
    }
    for(int i=1;i<=100;i++){
        count[i]+=count[i-1];
    }
    for(int i=n-1;i>=0;i--){
        b[--count[arr[i]]]=arr[i];
    }
    for(int i=0;i<n;i++){
        printf("%d ",b[i]);
    }
}


6. Merge Sort:

//Merge sort
#include <stdio.h>
void merge(int arr[], int low, int mid, int high){
    int i=low;
    int j=mid+1;
    int b[1000];
    int k=0;
    while(i<=mid && j<=high){
        if(arr[i]<=arr[j]){
            b[k]=arr[i];
            k++;
            i++;
        }
        else{
            b[k]=arr[j];
            k++;
            j++;
        }
    }
    if(i>mid){
        while(j<=high){
            b[k]=arr[j];
            j++;
            k++;
            }
        }
    else if(j>high){
        while(i<=mid){
            b[k]=arr[i];
            i++;
            k++;
        }
    }
    for(int i=0;i<=high-low;i++){
        arr[low+i]=b[i];
    }
}
void merge_sort(int arr[], int low, int high){
    if(low<high){
        int mid=(low+high)/2;
        merge_sort(arr,low,mid);
        merge_sort(arr,mid+1,high);
        merge(arr,low,mid,high);
    }
}
int main(){
    int n;
    scanf("%d",&n);
    int arr[n];
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    int low=0;
    int high=n-1;
    merge_sort(arr,low,high);
    for(int i=0;i<n;i++){
        printf("%d ",arr[i]);
    }
}

7. Quick sort:

//quick sort
// You are using GCC
#include <stdio.h>
void swap(int *a, int *b){
    int temp=*a;
    *a=*b;
    *b=temp;
}
int partition(int arr[],int low, int high){
    int pivot=arr[low];
    int i=low;
    int j=high;
    while(i<j){
        while(arr[i]<=pivot){
            i++;
        }
        while(arr[j]>pivot){
            j--;
        }
        if(i<j){
            swap(&arr[i],&arr[j]);
        }
    }
    swap(&arr[low],&arr[j]);
    return j;
}
void qs(int arr[], int low, int high){
    if(low<high){
        int p=partition(arr,low,high);
        qs(arr,low,p-1);
        qs(arr,p+1,high);
    }
}
int main(){
    int n;
    scanf("%d",&n);
    int arr[n];
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    int low=0;
    int high=n-1;
    qs(arr,low,high);
    for(int i=0;i<n;i++){
        printf("%d ",arr[i]);
    }
}

## Theory:


1. insertion sort :
best o(n) 1,2,3,4
worst o(n2) 4,3,2,1 
(not suitable for large input o(n2))

2. selection sort :
n-1 steps(passes)
n(n-1)/2 comparisions 
a[j]<a[min]
worst, best case o(n2)
needs minimum no of swaps

3. bubble sort
(n-1) passes
best case o(n)
worst case o(n2)
n-1 iterations

4. merge sort
worst best o(nlogn)
space complexity o(n)

5. counting sort
o(n+k) (k=high-low+1)

6. quick sort
best : o(nlogn) 
worst: o(n2)
space comp o(nlogn)
in place sorting algo(no extra space)

**(quick and selection is not stable everyone else stable)
i.e to preserve relative order

Sometimes, algorithms use O(log n) space for the call stack (e.g., recursive Quick Sort). Even then, we still call it in-place because:

No extra space proportional to the input is used.
